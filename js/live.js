// ===== MODULE DE SYNCHRONISATION LIVE =====

/**
 * Module de gestion de la synchronisation live avec JSONBin.io
 * Permet le partage en temps r√©el des donn√©es de match
 */

// ===== CONFIGURATION =====
const LIVE_CONFIG = {
    // Cl√© API JSONBin.io (√† remplacer par votre cl√©)
    API_KEY: '$2a$10$r5MbOaRyivoihBZSwAHKkOmtvWIkz6d7lOgfXHlj/0V.YKj4HSQfe',
    BASE_URL: 'https://api.jsonbin.io/v3/b',
    UPDATE_INTERVAL: 5000, // 5 secondes
    MAX_RETRIES: 3,
    TIMEOUT: 10000, // 10 secondes
    
    // Headers pour les requ√™tes
    getHeaders() {
        return {
            'Content-Type': 'application/json',
            'X-Master-Key': this.API_KEY,
            'X-Access-Key': this.API_KEY
        };
    }
};

// ===== VARIABLES GLOBALES =====
let liveState = {
    isActive: false,
    matchId: null,
    binId: null,
    lastUpdate: null,
    updateInterval: null,
    spectatorMode: false,
    connectionStatus: 'disconnected', // disconnected, connecting, connected, error
    retryCount: 0,
    lastSyncTime: null,
    syncQueue: []
};

// ===== FONCTIONS PRINCIPALES =====

/**
 * Initialisation du mode live
 */
async function initializeLive() {
    console.log('üî¥ Initialisation du module Live');
    
    // V√©rifier si on est en mode spectateur
    checkSpectatorMode();
    
    // Charger l'√©tat sauvegard√©
    loadLiveState();
    
    // D√©marrer la synchronisation si n√©cessaire
    if (liveState.isActive && liveState.binId) {
        await startLiveSync();
    }
    
    console.log('‚úÖ Module Live initialis√©');
}

/**
 * V√©rification du mode spectateur via l'URL
 */
function checkSpectatorMode() {
    const urlParams = new URLSearchParams(window.location.search);
    const liveId = urlParams.get('live');
    const binId = urlParams.get('bin');
    
    if (liveId) {
        liveState.spectatorMode = true;
        liveState.matchId = liveId;
        liveState.binId = binId;
        liveState.isActive = true;
        
        console.log('üëÅÔ∏è Mode spectateur activ√©:', { liveId, binId });
        return true;
    }
    
    return false;
}

// ===== G√âN√âRATION ET PARTAGE =====

/**
 * G√©n√©ration d'un lien live
 */
async function generateLiveLink() {
    try {
        updateConnectionStatus('connecting', 'G√©n√©ration du lien live...');
        
        // Pr√©parer les donn√©es du match
        const matchData = await prepareMatchData();
        
        if (!matchData) {
            throw new Error('Aucune donn√©e de match disponible');
        }
        
        // Cr√©er un nouvel ID de match si n√©cessaire
        if (!liveState.matchId) {
            liveState.matchId = 'match_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }
        
        // Ajouter les m√©tadonn√©es
        const liveData = {
            ...matchData,
            liveInfo: {
                matchId: liveState.matchId,
                createdAt: new Date().toISOString(),
                lastUpdate: new Date().toISOString(),
                version: '1.0'
            }
        };
        
        // Uploader vers JSONBin
        const binId = await uploadToJsonBin(liveData);
        
        if (binId) {
            liveState.binId = binId;
            liveState.isActive = true;
            liveState.lastUpdate = new Date().toISOString();
            
            // Sauvegarder l'√©tat
            saveLiveState();
            
            // D√©marrer la synchronisation
            await startLiveSync();
            
            // G√©n√©rer l'URL
            const baseUrl = window.location.origin + window.location.pathname.replace(/[^/]*$/, '');
            const liveUrl = `${baseUrl}pages/live.html?live=${liveState.matchId}&bin=${binId}`;
            
            updateConnectionStatus('connected', 'Lien live g√©n√©r√© avec succ√®s');
            
            return {
                url: liveUrl,
                matchId: liveState.matchId,
                binId: binId,
                qrCode: await generateQRCode(liveUrl)
            };
        } else {
            throw new Error('√âchec de l\'upload vers JSONBin');
        }
        
    } catch (error) {
        console.error('Erreur g√©n√©ration lien live:', error);
        updateConnectionStatus('error', 'Erreur lors de la g√©n√©ration: ' + error.message);
        throw error;
    }
}

/**
 * Pr√©paration des donn√©es du match pour le live
 */
async function prepareMatchData() {
    try {
        // R√©cup√©rer les donn√©es depuis l'application
        if (typeof footballApp !== 'undefined') {
            const state = footballApp.getState();
            const config = typeof getMatchConfig === 'function' ? getMatchConfig() : {};
            
            return {
                config: config,
                players: state.players || [],
                events: state.events || [],
                score: state.score || { team: 0, opponent: 0 },
                time: state.time || 0,
                half: state.half || 1,
                isPlaying: state.isPlaying || false
            };
        }
        
        // Fallback: donn√©es depuis le module match si disponible
        if (typeof matchModule !== 'undefined') {
            const matchState = matchModule.getState();
            return {
                config: { teamName: 'Mon √âquipe', opponentName: '√âquipe Adverse' },
                players: [],
                events: matchState.events || [],
                score: { team: 0, opponent: 0 },
                time: matchState.currentTime / 60,
                half: matchState.currentHalf,
                isPlaying: matchState.isPlaying
            };
        }
        
        return null;
    } catch (error) {
        console.error('Erreur pr√©paration donn√©es:', error);
        return null;
    }
}

// ===== SYNCHRONISATION =====

/**
 * D√©marrage de la synchronisation live
 */
async function startLiveSync() {
    if (liveState.updateInterval) {
        clearInterval(liveState.updateInterval);
    }
    
    if (liveState.spectatorMode) {
        // Mode spectateur: r√©cup√©ration p√©riodique
        liveState.updateInterval = setInterval(async () => {
            await fetchLiveData();
        }, LIVE_CONFIG.UPDATE_INTERVAL);
        
        // Premi√®re r√©cup√©ration imm√©diate
        await fetchLiveData();
    } else {
        // Mode cr√©ateur: envoi p√©riodique
        liveState.updateInterval = setInterval(async () => {
            await pushLiveData();
        }, LIVE_CONFIG.UPDATE_INTERVAL);
        
        console.log('üîÑ Synchronisation live d√©marr√©e (mode cr√©ateur)');
    }
}

/**
 * Arr√™t de la synchronisation live
 */
function stopLiveSync() {
    if (liveState.updateInterval) {
        clearInterval(liveState.updateInterval);
        liveState.updateInterval = null;
    }
    
    liveState.isActive = false;
    updateConnectionStatus('disconnected', 'Synchronisation arr√™t√©e');
    
    console.log('‚èπÔ∏è Synchronisation live arr√™t√©e');
}

/**
 * Envoi des donn√©es vers JSONBin (mode cr√©ateur)
 */
async function pushLiveData() {
    if (!liveState.binId) return;
    
    try {
        const matchData = await prepareMatchData();
        if (!matchData) return;
        
        // Ajouter les m√©tadonn√©es de mise √† jour
        const liveData = {
            ...matchData,
            liveInfo: {
                matchId: liveState.matchId,
                lastUpdate: new Date().toISOString(),
                updateCount: (liveState.updateCount || 0) + 1
            }
        };
        
        const success = await updateJsonBin(liveState.binId, liveData);
        
        if (success) {
            liveState.lastSyncTime = new Date().toISOString();
            liveState.updateCount = (liveState.updateCount || 0) + 1;
            liveState.retryCount = 0;
            
            updateConnectionStatus('connected', `Synchronis√© ‚Ä¢ ${new Date().toLocaleTimeString()}`);
        } else {
            throw new Error('√âchec de la mise √† jour');
        }
        
    } catch (error) {
        console.error('Erreur push live:', error);
        handleSyncError(error);
    }
}

/**
 * R√©cup√©ration des donn√©es depuis JSONBin (mode spectateur)
 */
async function fetchLiveData() {
    if (!liveState.binId) return;
    
    try {
        updateConnectionStatus('connecting', 'R√©cup√©ration des donn√©es...');
        
        const data = await downloadFromJsonBin(liveState.binId);
        
        if (data) {
            // V√©rifier si c'est une mise √† jour
            const isNewData = !liveState.lastUpdate || 
                             (data.liveInfo && data.liveInfo.lastUpdate !== liveState.lastUpdate);
            
            if (isNewData) {
                await applyLiveData(data);
                liveState.lastUpdate = data.liveInfo?.lastUpdate || new Date().toISOString();
                liveState.retryCount = 0;
                
                updateConnectionStatus('connected', `Mis √† jour ‚Ä¢ ${new Date().toLocaleTimeString()}`);
                console.log('üì• Donn√©es live re√ßues et appliqu√©es');
            } else {
                updateConnectionStatus('connected', `En ligne ‚Ä¢ ${new Date().toLocaleTimeString()}`);
            }
        } else {
            throw new Error('Aucune donn√©e re√ßue');
        }
        
    } catch (error) {
        console.error('Erreur fetch live:', error);
        handleSyncError(error);
    }
}

/**
 * Application des donn√©es live re√ßues
 */
async function applyLiveData(data) {
    try {
        // Mettre √† jour l'application si on est en mode spectateur
        if (liveState.spectatorMode && typeof displayMatchData === 'function') {
            displayMatchData(data);
        } else if (typeof footballApp !== 'undefined') {
            // Mettre √† jour l'√©tat de l'application
            const state = footballApp.getState();
            
            if (data.events) state.events = data.events;
            if (data.score) state.score = data.score;
            if (data.time !== undefined) state.time = data.time;
            if (data.half !== undefined) state.half = data.half;
            if (data.players) state.players = data.players;
            
            // D√©clencher la mise √† jour de l'affichage
            if (typeof footballApp.updateAllDisplays === 'function') {
                footballApp.updateAllDisplays();
            }
        }
        
        // D√©clencher un √©v√©nement personnalis√©
        if (typeof window !== 'undefined') {
            window.dispatchEvent(new CustomEvent('liveDataUpdated', { 
                detail: data 
            }));
        }
        
    } catch (error) {
        console.error('Erreur application donn√©es live:', error);
    }
}

// ===== API JSONBIN.IO =====

/**
 * Upload initial vers JSONBin
 */
async function uploadToJsonBin(data) {
    try {
        const response = await fetchWithTimeout(LIVE_CONFIG.BASE_URL, {
            method: 'POST',
            headers: LIVE_CONFIG.getHeaders(),
            body: JSON.stringify(data)
        });
        
        if (response.ok) {
            const result = await response.json();
            console.log('üì§ Donn√©es upload√©es vers JSONBin:', result.metadata.id);
            return result.metadata.id;
        } else {
            const errorText = await response.text();
            throw new Error(`HTTP ${response.status}: ${errorText}`);
        }
    } catch (error) {
        console.error('Erreur upload JSONBin:', error);
        return null;
    }
}

/**
 * Mise √† jour des donn√©es dans JSONBin
 */
async function updateJsonBin(binId, data) {
    try {
        const response = await fetchWithTimeout(`${LIVE_CONFIG.BASE_URL}/${binId}`, {
            method: 'PUT',
            headers: LIVE_CONFIG.getHeaders(),
            body: JSON.stringify(data)
        });
        
        if (response.ok) {
            console.log('üîÑ Donn√©es mises √† jour dans JSONBin');
            return true;
        } else {
            const errorText = await response.text();
            throw new Error(`HTTP ${response.status}: ${errorText}`);
        }
    } catch (error) {
        console.error('Erreur update JSONBin:', error);
        return false;
    }
}

/**
 * T√©l√©chargement des donn√©es depuis JSONBin
 */
async function downloadFromJsonBin(binId) {
    try {
        const response = await fetchWithTimeout(`${LIVE_CONFIG.BASE_URL}/${binId}/latest`, {
            method: 'GET',
            headers: {
                'X-Master-Key': LIVE_CONFIG.API_KEY
            }
        });
        
        if (response.ok) {
            const result = await response.json();
            return result.record;
        } else {
            const errorText = await response.text();
            throw new Error(`HTTP ${response.status}: ${errorText}`);
        }
    } catch (error) {
        console.error('Erreur download JSONBin:', error);
        return null;
    }
}

/**
 * Fetch avec timeout
 */
async function fetchWithTimeout(url, options = {}) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), LIVE_CONFIG.TIMEOUT);
    
    try {
        const response = await fetch(url, {
            ...options,
            signal: controller.signal
        });
        clearTimeout(timeoutId);
        return response;
    } catch (error) {
        clearTimeout(timeoutId);
        throw error;
    }
}

// ===== GESTION D'ERREURS =====

/**
 * Gestion des erreurs de synchronisation
 */
function handleSyncError(error) {
    liveState.retryCount++;
    
    if (liveState.retryCount <= LIVE_CONFIG.MAX_RETRIES) {
        const retryDelay = Math.min(1000 * Math.pow(2, liveState.retryCount), 10000);
        
        updateConnectionStatus('error', 
            `Erreur ‚Ä¢ Nouvelle tentative dans ${Math.round(retryDelay/1000)}s (${liveState.retryCount}/${LIVE_CONFIG.MAX_RETRIES})`
        );
        
        setTimeout(() => {
            if (liveState.spectatorMode) {
                fetchLiveData();
            } else {
                pushLiveData();
            }
        }, retryDelay);
    } else {
        updateConnectionStatus('error', 'Connexion √©chou√©e ‚Ä¢ Arr√™t de la synchronisation');
        stopLiveSync();
        
        if (typeof showNotification === 'function') {
            showNotification('Synchronisation live √©chou√©e apr√®s plusieurs tentatives', 'error');
        }
    }
}

/**
 * Mise √† jour du statut de connexion
 */
function updateConnectionStatus(status, message) {
    liveState.connectionStatus = status;
    
    // Mettre √† jour l'interface si les √©l√©ments existent
    const statusIcon = document.getElementById('statusIcon');
    const statusText = document.getElementById('statusText');
    const lastUpdate = document.getElementById('lastUpdate');
    
    const statusIcons = {
        disconnected: '‚ö´',
        connecting: 'üîÑ',
        connected: 'üü¢',
        error: 'üî¥'
    };
    
    if (statusIcon) {
        statusIcon.textContent = statusIcons[status] || '‚ö´';
    }
    
    if (statusText) {
        statusText.textContent = message || status;
    }
    
    if (lastUpdate && status === 'connected') {
        lastUpdate.textContent = `Derni√®re sync: ${new Date().toLocaleTimeString()}`;
    }
    
    console.log(`üì° Live Status: ${status} - ${message}`);
}

// ===== UTILITAIRES =====

/**
 * G√©n√©ration d'un QR Code pour le lien live
 */
async function generateQRCode(url) {
    try {
        // Utiliser l'API QR Server gratuite
        const qrUrl = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(url)}`;
        return qrUrl;
    } catch (error) {
        console.error('Erreur g√©n√©ration QR Code:', error);
        return null;
    }
}

/**
 * Copie du lien live dans le presse-papiers
 */
async function copyLiveLink(url) {
    try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(url);
            return true;
        } else {
            // Fallback pour les navigateurs plus anciens
            const textArea = document.createElement('textarea');
            textArea.value = url;
            textArea.style.position = 'fixed';
            textArea.style.opacity = '0';
            document.body.appendChild(textArea);
            textArea.select();
            textArea.setSelectionRange(0, 99999);
            
            const successful = document.execCommand('copy');
            document.body.removeChild(textArea);
            
            return successful;
        }
    } catch (error) {
        console.error('Erreur copie lien:', error);
        return false;
    }
}

/**
 * Partage natif du lien live (mobile)
 */
async function shareLiveLink(url, title = 'Match Live - Football Stats') {
    try {
        if (navigator.share) {
            await navigator.share({
                title: title,
                text: 'Suivez le match en direct !',
                url: url
            });
            return true;
        } else {
            // Fallback: copier dans le presse-papiers
            return await copyLiveLink(url);
        }
    } catch (error) {
        console.error('Erreur partage lien:', error);
        return false;
    }
}

// ===== SAUVEGARDE ET CHARGEMENT =====

/**
 * Sauvegarde de l'√©tat live
 */
function saveLiveState() {
    try {
        const dataToSave = {
            ...liveState,
            updateInterval: null // Ne pas sauvegarder l'interval
        };
        
        localStorage.setItem('footballLive_state', JSON.stringify(dataToSave));
    } catch (error) {
        console.error('Erreur sauvegarde √©tat live:', error);
    }
}

/**
 * Chargement de l'√©tat live
 */
function loadLiveState() {
    try {
        const saved = localStorage.getItem('footballLive_state');
        
        if (saved) {
            const data = JSON.parse(saved);
            liveState = {
                ...liveState,
                ...data,
                updateInterval: null,
                connectionStatus: 'disconnected'
            };
            
            console.log('√âtat live charg√©:', liveState);
        }
    } catch (error) {
        console.error('Erreur chargement √©tat live:', error);
    }
}

/**
 * Nettoyage de l'√©tat live
 */
function cleanupLive() {
    stopLiveSync();
    saveLiveState();
    console.log('üßπ Module Live nettoy√©');
}

// ===== FONCTIONS PUBLIQUES =====

/**
 * API publique du module live
 */
const liveModule = {
    // Initialisation
    init: initializeLive,
    cleanup: cleanupLive,
    
    // G√©n√©ration et partage
    generateLink: generateLiveLink,
    copyLink: copyLiveLink,
    shareLink: shareLiveLink,
    
    // Synchronisation
    start: startLiveSync,
    stop: stopLiveSync,
    push: pushLiveData,
    fetch: fetchLiveData,
    
    // √âtat
    getState: () => ({ ...liveState }),
    isActive: () => liveState.isActive,
    isSpectator: () => liveState.spectatorMode,
    getStatus: () => liveState.connectionStatus,
    
    // Utilitaires
    prepareData: prepareMatchData,
    updateStatus: updateConnectionStatus
};

// ===== EXPORT ET INITIALISATION =====

// Export global
if (typeof window !== 'undefined') {
    window.liveModule = liveModule;
    
    // Auto-initialisation
    document.addEventListener('DOMContentLoaded', function() {
        initializeLive();
    });
    
    // Nettoyage avant fermeture
    window.addEventListener('beforeunload', cleanupLive);
    
    // Gestionnaire de visibilit√© pour optimiser la synchronisation
    document.addEventListener('visibilitychange', function() {
        if (document.hidden && liveState.isActive) {
            // R√©duire la fr√©quence quand la page n'est pas visible
            if (liveState.updateInterval) {
                clearInterval(liveState.updateInterval);
                liveState.updateInterval = setInterval(() => {
                    if (liveState.spectatorMode) {
                        fetchLiveData();
                    } else {
                        pushLiveData();
                    }
                }, LIVE_CONFIG.UPDATE_INTERVAL * 2); // Double l'intervalle
            }
        } else if (!document.hidden && liveState.isActive) {
            // Reprendre la fr√©quence normale
            startLiveSync();
        }
    });
}

console.log('üì° Module Live charg√©');